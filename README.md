# motion-detection

## Описание практического задания:
Технологии и ограничения:
- Языки программирования: Java, Python, C++;
- Дополнительные библиотеки: OpenCV;

Постановка задачи:
1. Реализовать программный модуль опроса видеокамеры.  Для теста можно использовать видеокамеру Axis 214  192.168.217.103.
При этом допускается использование библиотеки Opencv.

2. Разработать два варианта детектора движения для выделения объектов переднего плана:
- детектор движения с использование функционала библиотеки opencv;
- детектор движения без использования сторонних библиотек;

3. С помощью оптического потока разработать модуль сопровождения (трекинга) объекта, выделенного при реализации п.2.
При этом отобразить сглаженную траекторию движения объекта.

## Зависимости
Проект реализован на языке `Python` с использованием следующих библиотек:
- `numpy` ([Ссылка на страницу с инструкцией по установке и документацией](https://numpy.org/)): хранение массивов и некоторые модули для работы с несколькими массивами (операция свертки `numpy.convolve2d()`, поиск среднего значения `numpy.mean()`) \
  Установить библиотеку можно с использованием pip3 следующей командой: `pip3 install numpy`
- `OpenCV` ([Ссылка на страницу с инструкцией по установке](https://opencv.org/get-started/)): считывание видео и кадров, использование функционала для детекции движения, трекинга выделенного объекта алгоритмом оптического потока. \
  Установить библиотеку можно с использованием pip3 следующей командой: `pip3 install opencv-python`

## Инструкция по запуску
Перед запуском необходимо скачать проект. Это можно сделать с помощью команды `https://github.com/AlexanderKamynin/motion-detection.git`.\
Запуск можно выполнить из корневой папки проекта с использованием команды `python3 main.py`.

## Описание решения
### Детекция движения с использованием библиотеки OpenCV.

Для детекции движения с использованием функционала библиотеки OpenCV реализован модуль `detectionCV.py` с классом `MotionDetectionCV`. В классе определен метод `detect()`, принимающий на вход два соседних по времени черно-белых изображения, а на выход выдающий словарь, в котором ключ - id выделенного объекта, значение - список с двумя кортежами, характеризующими левый верхний и правый нижний углы прямоугольника, описанного вокруг объекта.

В самом начале вычисляется разница между двумя кадрами с помощью `cv2.absdiff()`, после чего к данной разности применяется фильтр Гаусса `cv2.GaussianBlur()`, размывающий изображение, что позволяет уменьшить шум.

Размытое изображение передается в метод `cv2.threshold()`, который все пиксели, значение которых в черно-белом изображении меньше заданного значение порога `threshold`, устанавливает в значение 0 (черный цвет), иначе в 255 (белый цвет). К полученному результату применяется операция дилатации `cv2.dilate()`: расширение белых пикселей на изображении, благодаря чему контуры становятся более явными. 

Обработанное по итогу работы дилатации черно-белое изображение содержит в себе движимые объекты из белых пикселей, и фон черного цвета. Для того, чтобы убрать шум, который из-за дилатации мог увеличиться в размере, рассматриваются последние N (`max_frames` в коде модуля) результатов дилатации и усредняются между собой с помощью `np.mean()`. Полученное значение передается в метод `cv2.findContours()`, выдающим краевые точки обнаруженного контура объекта.

Методом `cv2.contourArea()` вычисляется площадь выделенных объектов. Те контуры, площадь которых меньше заданного порога `min_area`, убираются из рассмотрения. Далее удаляются все контуры, которые полностью оказались внутри любых других контуров.

Выделенным объектам присваиваются id, и их контуры (описанные прямоугольники) сохраняются в словаре `detected_objects`. Те id, центры которых не находятся ни в одном из выделенных на текущей итерации прямоугольниках, удаляются. Те контуры, которым не соответствует ни один выделенный на прошлых итерациях объект, добавляются как новый объект с новым id.

### Детекция движения без использования библиотеки OpenCV.

